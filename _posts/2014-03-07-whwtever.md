---
layout: post
title: Getting AngularJS to Play Nice with Other Libraries
tags:
- JavaScript
- AngularJS
---

I love [AngularJS](http://angularjs.org/). It is one of my favorite <abbr title="JavaScript">JS</abbr> libraries to work with. Once you get past the sharp learning curve, it provides a set of sane design patterns for making serious web applications. If you have worked with a lot of JS before, you know how valuable it can be to have a stringent platform - this goes here and that goes there. A lot of thinking has already been done for you!

In this tutorial we are going to begin looking at one of the not-so-nice (but necessary) aspects of AngularJS and an approach to dealing with it.

<!--more-->

## The Problem - It's all in the callbacks

Angular touts itself as being friendly with other libraries.

<blockquote cite="http://angularjs.org">
	<p>
		AngularJS works great with other technologies.
	</p>
</blockquote>

And it does! It works great with other technologies but only in a limited sense -- it won't interfere with other JavaScript(s) running on the same page. 

This is in itself really great! It's a more than most JS libraries and plugins can claim. But perhaps more accurately it should read:

> AngularJS works great with other technologies as long as they aren't trying to share information.

Sadly this doesn't have the same ring to it.

You see we start to run into problems when bringing other libraries into the context of AngularJS. These other libraries, unless they are crafted using AngularJS philosophies, will encounter issues in compatibility.

AngularJS is designed around a dirty-checking model. What this means is that after the framework has deemed something to have happened it will scour through the model to see if there have been any changes. If changes are detected, the framework then updates the appropriate portions of the view (HTML).

<blockquote cite="http://docs.angularjs.org/guide/scope">
	<p>
		When the browser calls into JavaScript the code executes outside the Angular execution context, which means that Angular is unaware of model modifications. To properly process model modifications the execution has to enter the Angular execution context using the <code><a href="http://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply">$apply</a></code> method. Only model modifications which execute inside the <code>$apply</code> method will be properly accounted for by Angular. For example if a directive listens on DOM events, such as <code><a href="http://docs.angularjs.org/api/ng/directive/ngClick">ng-click</a></code> it must evaluate the expression inside the <code>$apply</code> method.
	</p>
	<cite>
		<a href="http://docs.angularjs.org/guide/scope">Angular Docs</a>
	</cite>
</blockquote>

In other words, if something happens to the model outside of the AngularJS execution context, AngularJS will not know that changes have occurred. In order to fix it, we must force the model changes occur inside of an AngularJS context.

All callbacks managed through AngularJS are already tied in with the dirty-checking model. Anytime we `ng-click`, `$http`, `.resolve()` a promise, etc. the framework knows to check the model for changes because these components are connected to angular's scope model observation. On the other hand, callbacks passed to non-angular methods don't trigger model checking and as such won't have their changes reflected.
To demonstrate the problem we will start by constructing a simple AngularJS application.

{% highlight javascript html %}
{% raw %}
<!DOCTYPE html>
<html ng-app="angular-wrapper-demo">
<head>
	<title>Angular Wrapper Demo</title>
</head>
<body>
	<div ng-controller="myController">
		{{ username }}
		<button ng-click="logout()">Logout</button>
	</div>
	<script type="text/javascript" src="bower_components/angular/angular.min.js"></script>
	<script type="text/javascript">
		var app = angular.module('angular-wrapper-demo',[]);

		app.controller('myController',function myController($scope) {
			$scope.username = "Andrew";

			$scope.logout = function() {
				$scope.username = '';
			};
		});			
	</script>
</body>
</html>
{% endraw %}
{% endhighlight %}

Now this doesn't demonstrate the issue just yet. If you run the code you will see the username, "Andrew", show up just fine. When you click the logout button, the username changes to blank. This is what we would expect.

To see the problem, we need some JavaScript that executes outside of Angular's context. We are going to use a fake library that handles user login and logouts for us. Let's call it FameBook or FB for short.

{% highlight javascript html %}
{% raw %}
<!DOCTYPE html>
<html ng-app="angular-wrapper-demo">
<head>
	<title>Angular Wrapper Demo</title>
</head>
<body>
	<div ng-controller="myController">
		{{ username }}
		<button ng-click="logout()">Logout</button>
	</div>
	<script type="text/javascript" src="bower_components/angular/angular.min.js"></script>
	<script type="text/javascript">
		// Third party library for "FameBook" ;)
		var FB = { // <
			logout: function(callback) { // <
				// Simulate the effect of making an http request // <
				setTimeout(function(){ // <
					callback(); // <
				},0); // <
			} // <
		}; // <
	</script>
	<script type="text/javascript">
		// Put our third-party library into a service
		// so it can be injected into our controller
		angular.module('FB',[]).service('FB',function(){
			return FB;
		});
	</script>
	<script type="text/javascript">
		// Our app relies on the FB module
		var app = angular.module('angular-wrapper-demo',['FB']); // <

		app.controller('myController',function myController($scope, FB) {
			$scope.username = "Andrew";

			$scope.logout = function() {
				FB.logout(function(){ // <
					$scope.username = ''; // <
				}); // <
			};
		});		
	</script>
</body>
</html>
{% endraw %}
{% endhighlight %}

It doesn't work now!

## The Solution (sort of)

Anyone who is experienced with Angular will tell you it's easy to fix. All we need to do is place the callback into the AngularJS context. We do this using `$scope.$apply()`.

Jim Hoskins does a great job of explaining the concept in his article, [AngularJS and scope.$apply](http://jimhoskins.com/2012/12/17/angularjs-and-apply.html).

What we end up having to do is something like this in our controller:

{% highlight javascript javascript %}
app.controller('myController',function myController($scope, FB) {
	$scope.username = "Andrew";

	$scope.logout = function() {
		FB.logout(function(){
			$scope.$apply(function(){ // <
				$scope.username = '';
			}); // <
		});
	};
});
{% endhighlight %}

The arrows point to where we've inserted code to wrap the scope modifications into an Angular context. The code now works as before.

## A Better Solution

Now the above technique certainly gets the job done. It is however less than ideal. For one, it goes against <abbr title="Don't Repeat Yourself">DRY</abbr> principles.

The next step then seems to wrap said functionality into a function. We create a higher order function, `wrapCallback`. It takes a callback function as input and returns a new callback function that will execute in Angular context.

{% highlight javascript javascript %}
app.controller('myController',function myController($scope, FB) {
	$scope.username = "Andrew";

	function wrapCallback(callback) { // <
		return function() { // <
			$scope.$apply(function(){ // <
				callback(); // <
			}); // <
		}; // <
	} // <

	$scope.logout = function() {
		FB.logout(wrapCallback(function(){ // <
			$scope.username = '';
		})); // <
	};
});
{% endhighlight %}

## A Betterer Solution

Still we can do better. While our function does abstract away the `$scope.$apply` stuff, it will be useless outside of this controller. In order for it to work throughout our application, we should make it into a [service](http://docs.angularjs.org/guide/dev_guide.services).

{% highlight javascript javascript %}
var wrapper = angular.module('wrapper', []);

wrapper.service('wrapCallback', function(){
	return function wrapCallback(callback) {
		return function() {
			$scope.$apply(function(){
				callback();
			});
		};
	};
});
{% endhighlight %}

Here we create another module to house our wrapper function. We make the function into a service because in angular services are treated as singletons. Being as this is a pure function it only makes sense to have it as a singleton.

We then update our `app` module to have `wrapper` as a dependency and can inject `wrapCallback` into our controller.

{% highlight javascript javascript %}
// Our app relies on the FB module and the wrapper module
var app = angular.module('angular-wrapper-demo',['FB', 'wrapper']); // <

app.controller('myController',function myController($scope, FB, wrapCallback) { // <
	$scope.username = "Andrew";

	$scope.logout = function() {
		FB.logout(wrapCallback(function(){
			$scope.username = '';
		}));
	};
});
{% endhighlight %}

If we try running the code now we will get an error in the console:

{% highlight html %}
Uncaught ReferenceError: $scope is not defined
{% endhighlight %}

With the function no longer being defined inside of our controller, it can no longer be a [closure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures) for our `$scope`.

Thankfully AngularJS gives us the `$rootScope` service. It contains the scope of the entire application and all the controllers within. When we call `$rootScope.$apply` a recursive check is done on all `$scope`s including the one in our controller.

Of course this is not as efficient as have direct reference to the `$scope` object, but for our purposes it should be good enough.

All we have to do now is inject `$rootScope` into our service definition and then replace our call to `$scope.$apply` with `$rootScope.$apply`.

{% highlight javascript %}
wrapper.service('wrapCallback', function($rootScope){ // <
	return function wrapCallback(callback) {
		return function() {
			$rootScope.$apply(function(){ // <
				callback();
			});
		};
	};
});
{% endhighlight %}

Voila! Our function is now usable from any other controller or module in our application.

## Dealing with Callback Arguments

Let's imagine now that our FameBook library has another method, `getUserName`. It calls our callback and passes in the current username.

{% highlight javascript %}
var FB = {
	getUserName: function(callback) { // <
		setTimeout(function(){ // <
			callback("Frank"); // <
		}); // <
	}, // <
	logout: function(callback) {
		// Simulate the effect of making an http request
		setTimeout(function(){
			callback();
		},0);
	}
};
{% endhighlight %}

This is a common pattern when dealing with AJAXish libraries - we have to request data through them like a proxy.

In our controller, we would then want to be getting the username from the library instead of setting it ourselves with `$scope.username = "Andrew";`.

{% highlight javascript %}
FB.getUserName(function(username){
	$scope.username = username;
});
{% endhighlight %}

But of course we are smarter now! We know that we need to keep angular informed that something is happening on the scope. Thus we use `wrapCallback` again.

{% highlight javascript %}
app.controller('myController',function myController($scope, FB, wrapCallback) {
	FB.getUserName(wrapCallback(function(username){ // <
		$scope.username = username;
	})); // <

	$scope.logout = function() {
		FB.logout(wrapCallback(function(){
			$scope.username = '';
		}));
	};
});
{% endhighlight %}

We run it and ... nothing happens. What is going on? It worked just fine a second ago!

Let's throw a `console.log` into our callback to see if we can narrow down the issue.

{% highlight javascript %}
FB.getUserName(wrapCallback(function(username){
	console.log(username); // <
	$scope.username = username;
}));
{% endhighlight %}

Run it and you will see that `username` is `undefined`. How could it be `undefined`?! We can see very clearly, `callback("Frank");`, in `FB.getUserName`. It just doesn't seem possible that `"Frank"` is `undefined`.

Stop. Take a minute. [Hakuna your tatas](http://imgur.com/Y0P0BX1) as they say.

What is `callback` inside of `getUsername`? It's the callback generated by `wrapCallback` -- a function that is wrapping our callback function.

{% highlight javascript %}
wrapper.service('wrapCallback', function($rootScope){
	return function wrapCallback(callback) {
		return function() { // <
			$rootScope.$apply(function(){ // <
				callback(); // <
			}); // <
		}; // <
	};
});
{% endhighlight %}

You will notice that said function does not even take any arguments!

We need to fix this. The function we are returning needs to accept all of the same parameters as the original callback function. It also then needs to pass those parameters on to the original callback.

{% highlight javascript %}
return function(arg1) { // <
	$rootScope.$apply(function(){
		callback(arg1); // <
	});
};
{% endhighlight %}

This solution works in this particular scenario, but what happens when we need to have more than one argument being passed to our callback?

We need something like this:

{% highlight javascript %}
return function(arg1, arg2, ...) { // <
	$rootScope.$apply(function(){
		callback(arg1, arg2, ...); // <
	});
};
{% endhighlight %}

But of course this is not valid JavaScript.

Never fear! We can use the <code>[arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments)</code> object. Which is

<blockquote cite="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments">
	<p>
		An Array-like object corresponding to the arguments passed to a function.
	</p>
	<cite>
		<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments">MDN</a>
	</cite>
</blockquote>

It is an automatically generated reference to a function's arguments. It is available inside the body of any JavaScript function.

So if we do something like this:

{% highlight javascript %}
return function() {
	console.log(arguments); // <
	$rootScope.$apply(function(){
		callback();
	});
};
{% endhighlight %}

In the console we will see:

{% highlight html %}
["Frank"]
{% endhighlight %}

The username still isn't showing up, but at least now we have a reference for it. We just need to find a way to get `arguments` to our callback.

Because of how `arguments`' scoping works, it is connected only to the function definition immediately surrounding it. That means for our inner anonymous function to reference `arguments` from the outer anonymous function, we will need to store it in another variable.

{% highlight javascript %}
return function() {
	var args = arguments; // <
	$rootScope.$apply(function(){
		console.log(args); // <
		callback();
	});
};
{% endhighlight %}

This gives us the same result in the console as before.

Let's now pass `args` to `callback`. We can't just do this:

{% highlight javascript %}
return function() {
	var args = arguments;
	$rootScope.$apply(function(){
		callback(args); // <
	});
};
{% endhighlight %}

It will not work the way we intend since `args` is an "Array-like object" and our callback is expecting a string.

We need to instead use [Function.prototype.apply()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply).

<blockquote cite="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">
	<p>The <code><strong>apply()</strong></code> method calls a function with a given <code>this</code> value and <code>arguments</code> provided as an array (or an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Predefined_Core_Objects#Working_with_Array-like_objects">array-like object</a>).</p>
	<cite>
		<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">MDN</a>
	</cite>
</blockquote>

Which ends up looking like this:

{% highlight javascript %}
return function() {
	var args = arguments;
	$rootScope.$apply(function(){
		callback.apply(null, args); // <
	});
};
{% endhighlight %}

Awesome! Now our callback can take any number of arguments.

## This is This and That is That

Some libraries rely on using the `this` variable to relay information to your callback functions. [jQuery](http://jquery.com/) in particular does this with almost all of its methods.

We need to ensure that our callbacks execute with the correct `this`. We do this similarly to how we sent over our `arguments`.

{% highlight javascript %}
return function() {
	var that = this; // <
	var args = arguments;
	$rootScope.$apply(function(){
		callback.apply(that, args); // <
	});
};
{% endhighlight %}

Peace of cake!

## Not so Asynchronous After All

There is one more piece to the puzzle.

Some libraries also may or may not execute your callbacks asynchronously. To be more efficient they may be caching results of your requests. The [Facebook API](https://developers.facebook.com/docs/reference/javascript/FB.getLoginStatus/#servers) for example is guilty of doing this. It caches the user's login status.

Let's change our FameBook API so that it caches `username`.

{% highlight javascript %}
var FB = {
	username: null, // <
	getUserName: function(callback) {
		if (FB.username) { // <
			callback(FB.username); // <
		} else { // <
			setTimeout(function(){
				FB.username = "PacMan"; // <
				callback(FB.username);
			});
		} // <
	},
	logout: function(callback) {
		// Simulate the effect of making an http request
		setTimeout(function(){
			callback();
		},0);
	}
};
{% endhighlight %}

The first time we call `getUsername`, there is a cache miss and it does a "round-trip" to the server for the information. Our callback function is executed after the data has come back.

Any subsequent calls however will trigger a cache hit and our callback will execute immediately.

Let's modify our program slightly so that there is another controller which also makes a call to `getUserName`.

In our HTML:

{% highlight html %}
{% raw %}
<div ng-controller="myController">
	{{ username }}
	<button ng-click="logout()">Logout</button>
</div>
<div ng-controller="myOtherController"><!-- < -->
	<button ng-hide="username" ng-click="showUsername()">Show Me My Username</button><!-- < -->
	<span ng-show="username">Your username is {{username}}</span><!-- < -->
</div><!-- < -->
{% endraw %}
{% endhighlight %}

and then in our JavaScript:

{% highlight javascript %}
app.controller('myOtherController',function myOtherController($scope, FB, wrapCallback) {
	$scope.showUsername = function() {
		FB.getUserName(wrapCallback(function(username){
			$scope.username = username;
		}));
	};
});
{% endhighlight %}

When we click the button it should hide and display a message in its place.

If you click the button instead you will get an error in the console:

{% highlight html %}
Error: [$rootScope:inprog] http://errors.angularjs.org/1.2.14/$rootScope/inprog?p0=%24apply
{% endhighlight %}

Which links us to a page saying the error is:

<blockquote cite="http://docs.angularjs.org/error/$rootScope/inprog?p0=$apply">
	<p>
		$apply already in progress
	</p>
	<cite>
		<a href="http://docs.angularjs.org/error/$rootScope/inprog?p0=$apply">
			Angular Docs
		</a>
	</cite>
</blockquote>

Since our callback was executed immediately, we are already inside of the Angular execution context. This means we are calling `$scope.$apply` unnecessarily. Hence the error message.

To fix this, one solution is to make the function returned from `wrapCallback` aware if it is being called synchronously or asynchronously. If it is asynchronous then it will know to use `$scope.$apply`. Otherwise it can just assume it is already within the Angular execution context.

Since there is no inherent way to determine whether a function is being called asynchronously, we are going to need to use a bit of a hack. We create a variable, `async`, that acts as a flag saying whether or not the function is being called asynchronously. It starts out as false -  as in we are assuming the callback is executing synchronously.

We set a timeout that will change 

{% highlight javascript %}
wrapper.service('wrapCallback', function($rootScope){
	return function wrapCallback(callback) {
		var async = false; // <
		setTimeout(function(){ // <
			async = true; // <
		},0); // <
		return function() {
			var args = arguments;
			if (async) { // <
				$rootScope.$apply(function(){
					callback.apply(null, args);
				});
			} else { // <
				callback.apply(null, args); // <
			} // <
		};
	};
});
{% endhighlight %}

This kind of trick only works because JavaScript is single threaded.

## Conclusion

Blah blah blah.